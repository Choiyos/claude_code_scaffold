#!/usr/bin/env python3
"""
Claude Environment Management CLI Tool
Comprehensive configuration synchronization and management for Claude Code + SuperClaude + MCP

Modern CLI with interactive prompts, progress indicators, and comprehensive developer experience
Version: 2.0.0
Author: Claude Code Team
"""

import argparse
import json
import logging
import os
import sys
import subprocess
import hashlib
import time
import threading
import signal
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
import yaml
import requests
from dataclasses import dataclass
from enum import Enum

# Rich console for beautiful output
try:
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskID
    from rich.prompt import Prompt, Confirm, IntPrompt
    from rich.table import Table
    from rich.panel import Panel
    from rich.text import Text
    from rich.tree import Tree
    from rich.live import Live
    from rich.layout import Layout
    from rich.columns import Columns
    from rich import print as rprint
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    print("Warning: 'rich' package not found. Install with: pip install rich")
    # Fallback functions
    def rprint(*args, **kwargs):
        print(*args, **kwargs)

# Initialize Rich console
console = Console() if RICH_AVAILABLE else None

# Configure logging with Rich integration
if RICH_AVAILABLE:
    from rich.logging import RichHandler
    logging.basicConfig(
        level=logging.INFO,
        format='%(message)s',
        handlers=[RichHandler(console=console, rich_tracebacks=True)]
    )
else:
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

logger = logging.getLogger('claude-env')

class EnvironmentType(Enum):
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"

class SyncStatus(Enum):
    IN_SYNC = "in_sync"
    DRIFT_DETECTED = "drift_detected"
    SYNC_REQUIRED = "sync_required"
    SYNC_FAILED = "sync_failed"

class OperationStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"

@dataclass
class DriftItem:
    category: str
    severity: str
    description: str
    current_value: Any
    expected_value: Any
    remediation: str

@dataclass
class SyncResult:
    environment: str
    status: SyncStatus
    timestamp: datetime
    changes_applied: int
    drift_items: List[DriftItem]
    rollback_point: Optional[str]
    duration: float = 0.0
    
@dataclass
class OperationContext:
    operation: str
    environment: str
    user: str
    timestamp: datetime
    dry_run: bool = False
    force: bool = False
    
@dataclass
class CLIState:
    current_environment: str = "development"
    last_sync: Optional[datetime] = None
    interactive_mode: bool = True
    verbose: bool = False

class InteractiveUI:
    """Handles interactive user interface elements"""
    
    def __init__(self):
        self.console = console if RICH_AVAILABLE else None
        self.progress = None
        self.current_tasks = {}
    
    def show_welcome(self):
        """Display welcome message"""
        if self.console:
            welcome_panel = Panel(
                "[bold blue]Claude Environment Manager[/bold blue]\n"
                "[dim]Unified development environment for Claude Code + SuperClaude + MCP[/dim]",
                title="🚀 Claude-Env CLI",
                border_style="blue"
            )
            self.console.print(welcome_panel)
        else:
            print("\n🚀 Claude Environment Manager")
            print("Unified development environment for Claude Code + SuperClaude + MCP\n")
    
    def create_progress(self, description: str = "Processing...") -> Progress:
        """Create a progress bar"""
        if RICH_AVAILABLE:
            progress = Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                console=self.console
            )
            return progress
        return None
    
    def prompt_choice(self, message: str, choices: List[str], default: Optional[str] = None) -> str:
        """Prompt user for choice from list"""
        if RICH_AVAILABLE and self.console:
            if default:
                return Prompt.ask(message, choices=choices, default=default, console=self.console)
            return Prompt.ask(message, choices=choices, console=self.console)
        else:
            # Fallback for non-rich environments
            print(f"\n{message}")
            for i, choice in enumerate(choices, 1):
                print(f"  {i}. {choice}")
            
            while True:
                try:
                    selection = input(f"Select (1-{len(choices)}): ").strip()
                    if selection.isdigit():
                        idx = int(selection) - 1
                        if 0 <= idx < len(choices):
                            return choices[idx]
                    elif selection in choices:
                        return selection
                    elif default and not selection:
                        return default
                    print("Invalid choice. Please try again.")
                except KeyboardInterrupt:
                    sys.exit(1)
    
    def prompt_confirm(self, message: str, default: bool = False) -> bool:
        """Prompt user for confirmation"""
        if RICH_AVAILABLE and self.console:
            return Confirm.ask(message, default=default, console=self.console)
        else:
            default_text = "Y/n" if default else "y/N"
            response = input(f"{message} ({default_text}): ").strip().lower()
            if not response:
                return default
            return response in ['y', 'yes', 'true', '1']
    
    def show_table(self, title: str, headers: List[str], rows: List[List[str]]):
        """Display a formatted table"""
        if RICH_AVAILABLE and self.console:
            table = Table(title=title, show_header=True, header_style="bold magenta")
            for header in headers:
                table.add_column(header)
            for row in rows:
                table.add_row(*row)
            self.console.print(table)
        else:
            print(f"\n{title}")
            print("-" * len(title))
            print("\t".join(headers))
            print("-" * 50)
            for row in rows:
                print("\t".join(row))
            print()
    
    def show_status_panel(self, title: str, content: str, status: str = "info"):
        """Show status information in a panel"""
        if RICH_AVAILABLE and self.console:
            style_map = {
                "success": "green",
                "error": "red",
                "warning": "yellow",
                "info": "blue"
            }
            panel = Panel(
                content,
                title=title,
                border_style=style_map.get(status, "blue")
            )
            self.console.print(panel)
        else:
            status_icons = {
                "success": "✅",
                "error": "❌",
                "warning": "⚠️",
                "info": "ℹ️"
            }
            print(f"\n{status_icons.get(status, 'ℹ️')} {title}")
            print(content)
            print()

class ConfigurationManager:
    """Manages configuration files and their synchronization"""
    
    def __init__(self, config_dir: str = "./config", ui: Optional[InteractiveUI] = None):
        self.config_dir = Path(config_dir)
        self.claude_dir = Path.home() / ".claude"
        self.backup_dir = self.config_dir / "backups"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        self.ui = ui or InteractiveUI()
        
    def load_config(self, config_path: str) -> Dict:
        """Load configuration from file"""
        path = Path(config_path)
        try:
            if path.suffix in ['.yml', '.yaml']:
                with open(path, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f)
            elif path.suffix == '.json':
                with open(path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                raise ValueError(f"Unsupported config format: {path.suffix}")
        except Exception as e:
            logger.error(f"Failed to load config from {config_path}: {e}")
            raise
    
    def save_config(self, config: Dict, config_path: str) -> None:
        """Save configuration to file"""
        path = Path(config_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            if path.suffix in ['.yml', '.yaml']:
                with open(path, 'w', encoding='utf-8') as f:
                    yaml.dump(config, f, default_flow_style=False, indent=2)
            elif path.suffix == '.json':
                with open(path, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
            else:
                raise ValueError(f"Unsupported config format: {path.suffix}")
        except Exception as e:
            logger.error(f"Failed to save config to {config_path}: {e}")
            raise
    
    def get_config_hash(self, config: Dict) -> str:
        """Calculate hash of configuration for drift detection"""
        config_str = json.dumps(config, sort_keys=True, ensure_ascii=False)
        return hashlib.sha256(config_str.encode()).hexdigest()
    
    def backup_config(self, environment: str, description: str = "auto") -> str:
        """Create backup of current configuration with progress indication"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{environment}_{description}_{timestamp}"
        backup_path = self.backup_dir / backup_name
        backup_path.mkdir(parents=True, exist_ok=True)
        
        if RICH_AVAILABLE and self.ui.console:
            with self.ui.create_progress() as progress:
                task = progress.add_task("[cyan]Creating backup...", total=3)
                
                # Backup Claude directory
                progress.update(task, description="[cyan]Backing up Claude directory...")
                claude_backup = backup_path / "claude"
                claude_backup.mkdir(exist_ok=True)
                
                if self.claude_dir.exists():
                    subprocess.run([
                        "cp", "-r", str(self.claude_dir), str(claude_backup)
                    ], check=True)
                progress.advance(task)
                
                # Backup environment config
                progress.update(task, description="[cyan]Backing up environment config...")
                env_config_path = self.config_dir / "environments" / environment
                if env_config_path.exists():
                    env_backup = backup_path / "environment"
                    subprocess.run([
                        "cp", "-r", str(env_config_path), str(env_backup)
                    ], check=True)
                progress.advance(task)
                
                # Create metadata
                progress.update(task, description="[cyan]Creating metadata...")
                metadata = {
                    "timestamp": timestamp,
                    "environment": environment,
                    "description": description,
                    "claude_dir": str(self.claude_dir),
                    "config_dir": str(self.config_dir)
                }
                
                with open(backup_path / "metadata.json", 'w') as f:
                    json.dump(metadata, f, indent=2)
                progress.advance(task)
        else:
            print("Creating backup...")
            # Backup Claude directory
            claude_backup = backup_path / "claude"
            claude_backup.mkdir(exist_ok=True)
            
            if self.claude_dir.exists():
                subprocess.run([
                    "cp", "-r", str(self.claude_dir), str(claude_backup)
                ], check=True)
            
            # Backup environment config
            env_config_path = self.config_dir / "environments" / environment
            if env_config_path.exists():
                env_backup = backup_path / "environment"
                subprocess.run([
                    "cp", "-r", str(env_config_path), str(env_backup)
                ], check=True)
            
            # Create metadata
            metadata = {
                "timestamp": timestamp,
                "environment": environment,
                "description": description,
                "claude_dir": str(self.claude_dir),
                "config_dir": str(self.config_dir)
            }
            
            with open(backup_path / "metadata.json", 'w') as f:
                json.dump(metadata, f, indent=2)
        
        logger.info(f"Configuration backed up to: {backup_path}")
        return str(backup_path)

class DriftDetector:
    """Detects configuration drift between expected and actual states"""
    
    def __init__(self, config_manager: ConfigurationManager, ui: Optional[InteractiveUI] = None):
        self.config_manager = config_manager
        self.ui = ui or InteractiveUI()
    
    def detect_drift(self, environment: str, threshold: float = 0.05) -> List[DriftItem]:
        """Detect configuration drift for an environment"""
        drift_items = []
        
        try:
            # Load expected configuration
            expected_config = self._load_expected_config(environment)
            
            # Get current configuration
            current_config = self._get_current_config(environment)
            
            # Compare configurations
            drift_items.extend(self._compare_configs(expected_config, current_config))
            
            # Check MCP servers
            drift_items.extend(self._check_mcp_servers(environment))
            
            # Check file permissions and ownership
            drift_items.extend(self._check_file_permissions(environment))
            
            # Calculate drift percentage
            total_items = len(expected_config) if expected_config else 1
            drift_percentage = len(drift_items) / total_items
            
            if drift_percentage > threshold:
                logger.warning(f"Drift detected in {environment}: {drift_percentage:.2%}")
            else:
                logger.info(f"Configuration drift within threshold for {environment}")
            
        except Exception as e:
            logger.error(f"Failed to detect drift for {environment}: {e}")
            drift_items.append(DriftItem(
                category="error",
                severity="high",
                description=f"Drift detection failed: {e}",
                current_value=None,
                expected_value=None,
                remediation="Check system logs and retry"
            ))
        
        return drift_items
    
    def _load_expected_config(self, environment: str) -> Dict:
        """Load expected configuration for environment"""
        config_path = self.config_manager.config_dir / "environments" / environment / "config.yml"
        if config_path.exists():
            return self.config_manager.load_config(str(config_path))
        return {}
    
    def _get_current_config(self, environment: str) -> Dict:
        """Get current configuration from Claude directory"""
        current_config = {}
        
        # MCP configuration
        mcp_config_path = self.config_manager.claude_dir / "mcp.json"
        if mcp_config_path.exists():
            current_config["mcp"] = self.config_manager.load_config(str(mcp_config_path))
        
        # Settings configuration
        settings_path = self.config_manager.claude_dir / "settings.json"
        if settings_path.exists():
            current_config["settings"] = self.config_manager.load_config(str(settings_path))
        
        # SuperClaude metadata
        metadata_path = self.config_manager.claude_dir / ".superclaude-metadata.json"
        if metadata_path.exists():
            current_config["superclaude"] = self.config_manager.load_config(str(metadata_path))
        
        return current_config
    
    def _compare_configs(self, expected: Dict, current: Dict) -> List[DriftItem]:
        """Compare expected and current configurations"""
        drift_items = []
        
        def compare_recursive(exp_dict, cur_dict, path=""):
            for key, exp_value in exp_dict.items():
                current_key_path = f"{path}.{key}" if path else key
                
                if key not in cur_dict:
                    drift_items.append(DriftItem(
                        category="missing_key",
                        severity="medium",
                        description=f"Missing configuration key: {current_key_path}",
                        current_value=None,
                        expected_value=exp_value,
                        remediation=f"Add missing key {current_key_path}"
                    ))
                elif isinstance(exp_value, dict) and isinstance(cur_dict[key], dict):
                    compare_recursive(exp_value, cur_dict[key], current_key_path)
                elif exp_value != cur_dict[key]:
                    drift_items.append(DriftItem(
                        category="value_mismatch",
                        severity="low",
                        description=f"Value mismatch for {current_key_path}",
                        current_value=cur_dict[key],
                        expected_value=exp_value,
                        remediation=f"Update {current_key_path} to expected value"
                    ))
        
        compare_recursive(expected, current)
        return drift_items
    
    def _check_mcp_servers(self, environment: str) -> List[DriftItem]:
        """Check MCP server connectivity and configuration"""
        drift_items = []
        
        try:
            mcp_config_path = self.config_manager.claude_dir / "mcp.json"
            if not mcp_config_path.exists():
                return drift_items
            
            mcp_config = self.config_manager.load_config(str(mcp_config_path))
            servers = mcp_config.get("mcpServers", {})
            
            for server_name, server_config in servers.items():
                # Check if server is responding
                if not self._test_mcp_server_connectivity(server_name, server_config):
                    drift_items.append(DriftItem(
                        category="mcp_connectivity",
                        severity="high",
                        description=f"MCP server {server_name} is not responding",
                        current_value="unreachable",
                        expected_value="reachable",
                        remediation=f"Check and restart MCP server {server_name}"
                    ))
        
        except Exception as e:
            logger.error(f"Failed to check MCP servers: {e}")
        
        return drift_items
    
    def _test_mcp_server_connectivity(self, server_name: str, server_config: Dict) -> bool:
        """Test connectivity to MCP server"""
        try:
            # This is a simplified check - actual implementation would depend on MCP protocol
            command = server_config.get("command")
            if command:
                # Test if command is executable
                result = subprocess.run(
                    ["which", command[0]] if isinstance(command, list) else ["which", command],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
        except Exception:
            pass
        
        return False
    
    def _check_file_permissions(self, environment: str) -> List[DriftItem]:
        """Check file permissions and ownership"""
        drift_items = []
        
        try:
            claude_dir = self.config_manager.claude_dir
            if not claude_dir.exists():
                return drift_items
            
            # Check directory permissions
            stat_info = claude_dir.stat()
            expected_mode = 0o700  # rwx------
            current_mode = stat_info.st_mode & 0o777
            
            if current_mode != expected_mode:
                drift_items.append(DriftItem(
                    category="file_permissions",
                    severity="medium",
                    description=f"Incorrect permissions on {claude_dir}",
                    current_value=oct(current_mode),
                    expected_value=oct(expected_mode),
                    remediation=f"chmod {oct(expected_mode)} {claude_dir}"
                ))
        
        except Exception as e:
            logger.error(f"Failed to check file permissions: {e}")
        
        return drift_items

class SynchronizationEngine:
    """Handles configuration synchronization between environments"""
    
    def __init__(self, config_manager: ConfigurationManager, drift_detector: DriftDetector, ui: Optional[InteractiveUI] = None):
        self.config_manager = config_manager
        self.drift_detector = drift_detector
        self.ui = ui or InteractiveUI()
        self._cancelled = False
        
    def cancel_operation(self):
        """Cancel current operation"""
        self._cancelled = True
    
    def sync_environment(self, environment: str, dry_run: bool = False, 
                        force: bool = False, interactive: bool = True) -> SyncResult:
        """Synchronize configuration for an environment with interactive UI"""
        start_time = datetime.now()
        rollback_point = None
        drift_items = []
        
        try:
            if RICH_AVAILABLE and self.ui.console:
                with self.ui.create_progress() as progress:
                    # Phase 1: Validation
                    validation_task = progress.add_task("[cyan]Validating environment...", total=100)
                    if not self._validate_environment(environment):
                        raise ValueError(f"Environment {environment} validation failed")
                    progress.update(validation_task, completed=100)
                    
                    # Phase 2: Drift Detection
                    drift_task = progress.add_task("[cyan]Detecting configuration drift...", total=100)
                    drift_items = self.drift_detector.detect_drift(environment)
                    progress.update(drift_task, completed=100)
                    
                    if not drift_items:
                        self.ui.show_status_panel("Sync Status", f"✅ Environment '{environment}' is already in sync", "success")
                        return SyncResult(
                            environment=environment,
                            status=SyncStatus.IN_SYNC,
                            timestamp=start_time,
                            changes_applied=0,
                            drift_items=[],
                            rollback_point=None,
                            duration=(datetime.now() - start_time).total_seconds()
                        )
                    
                    # Show drift summary
                    if interactive and not dry_run:
                        self._show_drift_summary(drift_items)
                        if not self.ui.prompt_confirm(f"Apply {len(drift_items)} changes?", default=True):
                            self.ui.show_status_panel("Operation", "Sync cancelled by user", "warning")
                            return SyncResult(
                                environment=environment,
                                status=SyncStatus.SYNC_REQUIRED,
                                timestamp=start_time,
                                changes_applied=0,
                                drift_items=drift_items,
                                rollback_point=None,
                                duration=(datetime.now() - start_time).total_seconds()
                            )
                    
                    # Phase 3: Backup
                    if not dry_run:
                        backup_task = progress.add_task("[cyan]Creating backup...", total=100)
                        rollback_point = self.config_manager.backup_config(environment, "pre-sync")
                        progress.update(backup_task, completed=100)
                    
                    if dry_run:
                        self.ui.show_status_panel("Dry Run Results", f"Would apply {len(drift_items)} changes", "info")
                        return SyncResult(
                            environment=environment,
                            status=SyncStatus.SYNC_REQUIRED,
                            timestamp=start_time,
                            changes_applied=0,
                            drift_items=drift_items,
                            rollback_point=None,
                            duration=(datetime.now() - start_time).total_seconds()
                        )
                    
                    # Phase 4: Apply Changes
                    changes_task = progress.add_task("[cyan]Applying changes...", total=len(drift_items))
                    changes_applied = 0
                    
                    for i, item in enumerate(drift_items):
                        if self._cancelled:
                            raise KeyboardInterrupt("Operation cancelled")
                        
                        progress.update(changes_task, description=f"[cyan]Applying: {item.description[:50]}...")
                        
                        if self._apply_single_change(environment, item, force):
                            changes_applied += 1
                        
                        progress.update(changes_task, advance=1)
                    
                    # Phase 5: Validation
                    validation_task = progress.add_task("[cyan]Validating changes...", total=100)
                    post_sync_drift = self.drift_detector.detect_drift(environment)
                    progress.update(validation_task, completed=100)
            
            else:
                # Non-rich fallback
                logger.info(f"Starting sync for {environment} environment")
                
                if not self._validate_environment(environment):
                    raise ValueError(f"Environment {environment} validation failed")
                
                drift_items = self.drift_detector.detect_drift(environment)
                
                if not drift_items:
                    logger.info(f"No drift detected for {environment}")
                    return SyncResult(
                        environment=environment,
                        status=SyncStatus.IN_SYNC,
                        timestamp=start_time,
                        changes_applied=0,
                        drift_items=[],
                        rollback_point=None,
                        duration=(datetime.now() - start_time).total_seconds()
                    )
                
                if not dry_run:
                    rollback_point = self.config_manager.backup_config(environment, "pre-sync")
                
                if dry_run:
                    logger.info(f"Dry run: Would apply {len(drift_items)} changes")
                    return SyncResult(
                        environment=environment,
                        status=SyncStatus.SYNC_REQUIRED,
                        timestamp=start_time,
                        changes_applied=0,
                        drift_items=drift_items,
                        rollback_point=None,
                        duration=(datetime.now() - start_time).total_seconds()
                    )
                
                changes_applied = self._apply_changes(environment, drift_items, force)
                post_sync_drift = self.drift_detector.detect_drift(environment)
            
            # Determine final status
            if post_sync_drift and not force:
                logger.warning(f"Sync incomplete: {len(post_sync_drift)} issues remain")
                status = SyncStatus.SYNC_REQUIRED
            else:
                logger.info(f"Sync completed successfully for {environment}")
                status = SyncStatus.IN_SYNC
            
            duration = (datetime.now() - start_time).total_seconds()
            
            # Show completion summary
            if RICH_AVAILABLE and self.ui.console:
                self._show_sync_summary(environment, changes_applied, duration, status)
            
            return SyncResult(
                environment=environment,
                status=status,
                timestamp=start_time,
                changes_applied=changes_applied,
                drift_items=post_sync_drift,
                rollback_point=rollback_point,
                duration=duration
            )
        
        except KeyboardInterrupt:
            logger.warning("Sync operation cancelled")
            return SyncResult(
                environment=environment,
                status=SyncStatus.SYNC_FAILED,
                timestamp=start_time,
                changes_applied=0,
                drift_items=drift_items,
                rollback_point=rollback_point,
                duration=(datetime.now() - start_time).total_seconds()
            )
        except Exception as e:
            logger.error(f"Sync failed for {environment}: {e}")
            return SyncResult(
                environment=environment,
                status=SyncStatus.SYNC_FAILED,
                timestamp=start_time,
                changes_applied=0,
                drift_items=drift_items,
                rollback_point=rollback_point,
                duration=(datetime.now() - start_time).total_seconds()
            )
    
    def _show_drift_summary(self, drift_items: List[DriftItem]):
        """Show drift summary table"""
        if not RICH_AVAILABLE or not self.ui.console:
            return
            
        rows = []
        for item in drift_items:
            severity_icon = "🔴" if item.severity == "high" else "🟡" if item.severity == "medium" else "🟢"
            rows.append([
                severity_icon,
                item.category,
                item.description[:50] + "..." if len(item.description) > 50 else item.description,
                item.remediation[:30] + "..." if len(item.remediation) > 30 else item.remediation
            ])
        
        self.ui.show_table(
            "Configuration Drift Detected",
            ["Severity", "Category", "Description", "Remediation"],
            rows
        )
    
    def _show_sync_summary(self, environment: str, changes_applied: int, duration: float, status: SyncStatus):
        """Show sync completion summary"""
        if not RICH_AVAILABLE or not self.ui.console:
            return
            
        status_icon = "✅" if status == SyncStatus.IN_SYNC else "⚠️"
        content = f"{status_icon} Environment: {environment}\n"
        content += f"📝 Changes Applied: {changes_applied}\n"
        content += f"⏱️  Duration: {duration:.2f}s\n"
        content += f"📊 Status: {status.value.replace('_', ' ').title()}"
        
        panel_status = "success" if status == SyncStatus.IN_SYNC else "warning"
        self.ui.show_status_panel("Sync Complete", content, panel_status)
    
    def _validate_environment(self, environment: str) -> bool:
        """Validate environment configuration"""
        try:
            env_path = self.config_manager.config_dir / "environments" / environment
            return env_path.exists() and (env_path / "config.yml").exists()
        except Exception:
            return False
    
    def _apply_changes(self, environment: str, drift_items: List[DriftItem], force: bool) -> int:
        """Apply configuration changes"""
        changes_applied = 0
        
        for item in drift_items:
            try:
                if self._apply_single_change(environment, item, force):
                    changes_applied += 1
                    logger.info(f"Applied change: {item.description}")
                else:
                    logger.warning(f"Failed to apply change: {item.description}")
            
            except Exception as e:
                logger.error(f"Error applying change {item.description}: {e}")
                if not force:
                    raise
        
        return changes_applied
    
    def _apply_single_change(self, environment: str, drift_item: DriftItem, force: bool) -> bool:
        """Apply a single configuration change"""
        try:
            if drift_item.category == "missing_key":
                return self._add_missing_key(drift_item)
            elif drift_item.category == "value_mismatch":
                return self._update_value(drift_item)
            elif drift_item.category == "file_permissions":
                return self._fix_permissions(drift_item)
            elif drift_item.category == "mcp_connectivity":
                return self._fix_mcp_connectivity(drift_item, force)
            else:
                logger.warning(f"Unknown drift category: {drift_item.category}")
                return False
        
        except Exception as e:
            logger.error(f"Failed to apply change: {e}")
            return False
    
    def _add_missing_key(self, drift_item: DriftItem) -> bool:
        """Add missing configuration key"""
        # Implementation would depend on specific configuration structure
        logger.info(f"Adding missing key: {drift_item.description}")
        return True
    
    def _update_value(self, drift_item: DriftItem) -> bool:
        """Update configuration value"""
        logger.info(f"Updating value: {drift_item.description}")
        return True
    
    def _fix_permissions(self, drift_item: DriftItem) -> bool:
        """Fix file permissions"""
        try:
            # Extract path and mode from remediation
            if "chmod" in drift_item.remediation:
                parts = drift_item.remediation.split()
                mode = parts[1]
                path = parts[2]
                
                subprocess.run(["chmod", mode, path], check=True)
                return True
        except Exception as e:
            logger.error(f"Failed to fix permissions: {e}")
        
        return False
    
    def _fix_mcp_connectivity(self, drift_item: DriftItem, force: bool) -> bool:
        """Fix MCP server connectivity issues"""
        if not force:
            logger.warning("MCP connectivity issues require manual intervention or --force flag")
            return False
        
        logger.info(f"Attempting to fix MCP connectivity: {drift_item.description}")
        # Implementation would depend on specific MCP server management
        return True

class CLIManager:
    """Main CLI Manager with interactive features"""
    
    def __init__(self):
        self.ui = InteractiveUI()
        self.state = CLIState()
        self.config_manager = ConfigurationManager(ui=self.ui)
        self.drift_detector = DriftDetector(self.config_manager, self.ui)
        self.sync_engine = SynchronizationEngine(self.config_manager, self.drift_detector, self.ui)
        
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Handle interrupt signals gracefully"""
        self.ui.show_status_panel("Interrupted", "Operation cancelled by user", "warning")
        self.sync_engine.cancel_operation()
        sys.exit(1)
    
    def run_interactive_mode(self):
        """Run CLI in interactive mode"""
        self.ui.show_welcome()
        
        while True:
            try:
                if RICH_AVAILABLE:
                    self.ui.console.print("\n[bold blue]What would you like to do?[/bold blue]")
                else:
                    print("\nWhat would you like to do?")
                
                choices = [
                    "Sync environment",
                    "Check status",
                    "View configuration",
                    "Manage backups",
                    "Exit"
                ]
                
                action = self.ui.prompt_choice("Select an action", choices)
                
                if action == "Sync environment":
                    self._interactive_sync()
                elif action == "Check status":
                    self._interactive_status()
                elif action == "View configuration":
                    self._interactive_config()
                elif action == "Manage backups":
                    self._interactive_backups()
                elif action == "Exit":
                    if RICH_AVAILABLE:
                        self.ui.console.print("[dim]Goodbye! 👋[/dim]")
                    else:
                        print("Goodbye! 👋")
                    break
                    
            except KeyboardInterrupt:
                if self.ui.prompt_confirm("\nExit Claude-Env?", default=True):
                    break
            except Exception as e:
                logger.error(f"Error in interactive mode: {e}")
                if not self.ui.prompt_confirm("Continue?", default=True):
                    break
    
    def _interactive_sync(self):
        """Interactive sync workflow"""
        environments = ["development", "staging", "production"]
        environment = self.ui.prompt_choice("Select environment to sync", environments, 
                                          default=self.state.current_environment)
        
        dry_run = self.ui.prompt_confirm("Perform dry run first?", default=True)
        
        if dry_run:
            result = self.sync_engine.sync_environment(environment, dry_run=True)
            if result.drift_items:
                apply_changes = self.ui.prompt_confirm("Apply these changes?", default=True)
                if apply_changes:
                    self.sync_engine.sync_environment(environment, dry_run=False)
            else:
                self.ui.show_status_panel("Sync Status", "No changes needed", "success")
        else:
            self.sync_engine.sync_environment(environment, dry_run=False)
        
        self.state.current_environment = environment
        self.state.last_sync = datetime.now()
    
    def _interactive_status(self):
        """Interactive status check"""
        environment = self.ui.prompt_choice(
            "Check status for environment", 
            ["development", "staging", "production", "all"],
            default=self.state.current_environment
        )
        
        if environment == "all":
            for env in ["development", "staging", "production"]:
                drift_items = self.drift_detector.detect_drift(env)
                status = "✅ In Sync" if not drift_items else f"⚠️  {len(drift_items)} issues"
                self.ui.show_status_panel(f"Status: {env}", status, 
                                        "success" if not drift_items else "warning")
        else:
            drift_items = self.drift_detector.detect_drift(environment)
            if not drift_items:
                self.ui.show_status_panel(f"Status: {environment}", "✅ Environment is in sync", "success")
            else:
                self._show_drift_details(drift_items)
    
    def _interactive_config(self):
        """Interactive configuration management"""
        actions = ["View current config", "Edit config", "Validate config", "Back"]
        action = self.ui.prompt_choice("Configuration management", actions)
        
        if action == "View current config":
            # Implementation for viewing config
            self.ui.show_status_panel("Configuration", "Feature coming soon...", "info")
        elif action == "Edit config":
            # Implementation for editing config
            self.ui.show_status_panel("Configuration", "Feature coming soon...", "info")
        elif action == "Validate config":
            # Implementation for validating config
            self.ui.show_status_panel("Configuration", "Feature coming soon...", "info")
    
    def _interactive_backups(self):
        """Interactive backup management"""
        actions = ["List backups", "Create backup", "Restore backup", "Back"]
        action = self.ui.prompt_choice("Backup management", actions)
        
        if action == "Create backup":
            environment = self.ui.prompt_choice(
                "Create backup for environment",
                ["development", "staging", "production"]
            )
            description = input("Backup description (optional): ").strip() or "manual"
            backup_path = self.config_manager.backup_config(environment, description)
            self.ui.show_status_panel("Backup Created", f"Backup saved to:\n{backup_path}", "success")
        else:
            self.ui.show_status_panel("Backups", "Feature coming soon...", "info")
    
    def _show_drift_details(self, drift_items: List[DriftItem]):
        """Show detailed drift information"""
        rows = []
        for item in drift_items:
            severity_icon = "🔴" if item.severity == "high" else "🟡" if item.severity == "medium" else "🟢"
            rows.append([severity_icon, item.category, item.description, item.remediation])
        
        self.ui.show_table(
            f"Configuration Drift ({len(drift_items)} issues)",
            ["Severity", "Category", "Description", "Remediation"],
            rows
        )

def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Claude Environment Management CLI - Unified development environment for Claude Code + SuperClaude + MCP",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
🚀 Examples:
  claude-env                              # Interactive mode
  claude-env sync --environment development --dry-run
  claude-env status --check-drift --environment all
  claude-env rollback --to-backup latest
  claude-env config get mcp.servers
        """
    )
    
    # Global options
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--no-color', action='store_true', help='Disable colored output')
    parser.add_argument('--config-dir', default='./config', help='Configuration directory')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Sync command
    sync_parser = subparsers.add_parser('sync', help='Synchronize environment configuration')
    sync_parser.add_argument('--environment', '-e', choices=['development', 'staging', 'production'],
                           help='Target environment')
    sync_parser.add_argument('--team', help='Specific team configuration')
    sync_parser.add_argument('--project', help='Specific project configuration')
    sync_parser.add_argument('--dry-run', '-n', action='store_true', help='Show changes without applying')
    sync_parser.add_argument('--force', '-f', action='store_true', help='Force sync ignoring warnings')
    sync_parser.add_argument('--non-interactive', action='store_true', help='Run without interactive prompts')
    sync_parser.add_argument('--auto-approve', action='store_true', help='Automatically approve changes')
    
    # Status command
    status_parser = subparsers.add_parser('status', help='Check environment status')
    status_parser.add_argument('--check-drift', '-d', action='store_true', help='Check for configuration drift')
    status_parser.add_argument('--environment', '-e', choices=['development', 'staging', 'production', 'all'],
                             help='Specific environment to check')
    status_parser.add_argument('--detailed', action='store_true', help='Show detailed status information')
    status_parser.add_argument('--json', action='store_true', help='Output in JSON format')
    
    # Config command
    config_parser = subparsers.add_parser('config', help='Manage configuration')
    config_subparsers = config_parser.add_subparsers(dest='config_action')
    
    get_parser = config_subparsers.add_parser('get', help='Get configuration value')
    get_parser.add_argument('key', help='Configuration key to retrieve')
    get_parser.add_argument('--environment', '-e', help='Environment context')
    get_parser.add_argument('--json', action='store_true', help='Output in JSON format')
    
    set_parser = config_subparsers.add_parser('set', help='Set configuration value')
    set_parser.add_argument('key', help='Configuration key to set')
    set_parser.add_argument('value', help='Configuration value')
    set_parser.add_argument('--environment', '-e', help='Environment context')
    
    validate_parser = config_subparsers.add_parser('validate', help='Validate configuration')
    validate_parser.add_argument('--environment', '-e', help='Environment to validate')
    validate_parser.add_argument('--fix', action='store_true', help='Auto-fix validation issues')
    
    edit_parser = config_subparsers.add_parser('edit', help='Edit configuration interactively')
    edit_parser.add_argument('--environment', '-e', help='Environment to edit')
    
    list_parser = config_subparsers.add_parser('list', help='List all configuration keys')
    list_parser.add_argument('--environment', '-e', help='Environment context')
    
    # Rollback command
    rollback_parser = subparsers.add_parser('rollback', help='Rollback configuration')
    rollback_parser.add_argument('--to-version', help='Rollback to specific version')
    rollback_parser.add_argument('--to-commit', help='Rollback to specific commit')
    rollback_parser.add_argument('--to-backup', help='Rollback to specific backup')
    rollback_parser.add_argument('--list-backups', action='store_true', help='List available backups')
    rollback_parser.add_argument('--environment', '-e', help='Environment context')
    rollback_parser.add_argument('--force', '-f', action='store_true', help='Force rollback without confirmation')
    
    # Diff command
    diff_parser = subparsers.add_parser('diff', help='Compare configurations')
    diff_parser.add_argument('--compare-with', choices=['remote', 'baseline', 'backup'], 
                           default='remote', help='What to compare against')
    diff_parser.add_argument('--environment', '-e', help='Environment to compare')
    diff_parser.add_argument('--output', choices=['table', 'json', 'yaml'], default='table', 
                           help='Output format')
    
    # Backup command
    backup_parser = subparsers.add_parser('backup', help='Manage backups')
    backup_subparsers = backup_parser.add_subparsers(dest='backup_action')
    
    create_backup_parser = backup_subparsers.add_parser('create', help='Create backup')
    create_backup_parser.add_argument('--environment', '-e', required=True, help='Environment to backup')
    create_backup_parser.add_argument('--description', '-d', help='Backup description')
    
    list_backup_parser = backup_subparsers.add_parser('list', help='List backups')
    list_backup_parser.add_argument('--environment', '-e', help='Filter by environment')
    
    restore_backup_parser = backup_subparsers.add_parser('restore', help='Restore from backup')
    restore_backup_parser.add_argument('backup_id', help='Backup ID to restore')
    restore_backup_parser.add_argument('--force', '-f', action='store_true', help='Force restore without confirmation')
    
    # Interactive command (default when no args)
    interactive_parser = subparsers.add_parser('interactive', help='Run in interactive mode')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show version information')
    
    args = parser.parse_args()
    
    # Initialize CLI manager
    cli_manager = CLIManager()
    
    # Set verbosity
    if hasattr(args, 'verbose') and args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        cli_manager.state.verbose = True
    
    # Disable color if requested
    if hasattr(args, 'no_color') and args.no_color and RICH_AVAILABLE:
        console._color_system = None
    
    # If no command specified, run interactive mode
    if not args.command:
        try:
            cli_manager.run_interactive_mode()
            return 0
        except KeyboardInterrupt:
            print("\nGoodbye! 👋")
            return 0
        except Exception as e:
            logger.error(f"Interactive mode failed: {e}")
            return 1
    
    try:
        if args.command == 'sync':
            return handle_sync_command(args, cli_manager)
        elif args.command == 'status':
            return handle_status_command(args, cli_manager)
        elif args.command == 'config':
            return handle_config_command(args, cli_manager)
        elif args.command == 'rollback':
            return handle_rollback_command(args, cli_manager)
        elif args.command == 'diff':
            return handle_diff_command(args, cli_manager)
        elif args.command == 'backup':
            return handle_backup_command(args, cli_manager)
        elif args.command == 'interactive':
            cli_manager.run_interactive_mode()
            return 0
        elif args.command == 'version':
            return handle_version_command(args)
        else:
            logger.error(f"Unknown command: {args.command}")
            return 1
    
    except KeyboardInterrupt:
        print("\nOperation cancelled")
        return 1
    except Exception as e:
        logger.error(f"Command failed: {e}")
        if cli_manager.state.verbose:
            import traceback
            traceback.print_exc()
        return 1

def handle_sync_command(args, cli_manager: CLIManager) -> int:
    """Handle sync command with enhanced UI"""
    if not args.environment:
        if cli_manager.ui.console:
            environment = cli_manager.ui.prompt_choice(
                "Select environment to sync",
                ['development', 'staging', 'production']
            )
        else:
            logger.error("Environment is required for sync command")
            return 1
    else:
        environment = args.environment
    
    interactive = not getattr(args, 'non_interactive', False)
    
    result = cli_manager.sync_engine.sync_environment(
        environment=environment,
        dry_run=args.dry_run,
        force=args.force,
        interactive=interactive
    )
    
    # Output results
    if RICH_AVAILABLE and cli_manager.ui.console:
        # Rich output already handled in sync_environment
        pass
    else:
        print(f"\nSync Result for {result.environment}:")
        print(f"  Status: {result.status.value}")
        print(f"  Changes Applied: {result.changes_applied}")
        print(f"  Duration: {result.duration:.2f}s")
        print(f"  Timestamp: {result.timestamp}")
        
        if result.drift_items:
            print(f"  Remaining Issues: {len(result.drift_items)}")
            for item in result.drift_items[:5]:  # Show first 5 issues
                print(f"    - {item.description}")
        
        if result.rollback_point:
            print(f"  Rollback Point: {result.rollback_point}")
    
    return 0 if result.status in [SyncStatus.IN_SYNC, SyncStatus.SYNC_REQUIRED] else 1

def handle_status_command(args, cli_manager: CLIManager) -> int:
    """Handle status command with enhanced UI"""
    environments = [args.environment] if args.environment and args.environment != 'all' else ['development', 'staging', 'production']
    
    if args.json:
        # JSON output for automation
        status_data = {}
        for env in environments:
            drift_items = cli_manager.drift_detector.detect_drift(env)
            status_data[env] = {
                'status': 'in_sync' if not drift_items else 'drift_detected',
                'issues': len(drift_items),
                'drift_items': [{
                    'category': item.category,
                    'severity': item.severity,
                    'description': item.description,
                    'remediation': item.remediation
                } for item in drift_items] if args.detailed else []
            }
        print(json.dumps(status_data, indent=2))
        return 0
    
    if args.check_drift or not args.environment:
        total_issues = 0
        for env in environments:
            drift_items = cli_manager.drift_detector.detect_drift(env)
            total_issues += len(drift_items)
            
            if RICH_AVAILABLE and cli_manager.ui.console:
                status = "in_sync" if not drift_items else "warning"
                content = f"✅ No issues detected" if not drift_items else f"⚠️  {len(drift_items)} issues found"
                
                if args.detailed and drift_items:
                    content += "\n\nIssues:"
                    for item in drift_items[:10]:  # Show first 10
                        severity_icon = "🔴" if item.severity == "high" else "🟡" if item.severity == "medium" else "🟢"
                        content += f"\n{severity_icon} {item.description}"
                    if len(drift_items) > 10:
                        content += f"\n... and {len(drift_items) - 10} more"
                
                cli_manager.ui.show_status_panel(f"Status: {env}", content, status)
            else:
                if not drift_items:
                    print(f"✅ No drift detected in {env}")
                else:
                    print(f"⚠️  Drift detected in {env}: {len(drift_items)} issues")
                    if args.detailed:
                        for item in drift_items:
                            severity_icon = "🔴" if item.severity == "high" else "🟡" if item.severity == "medium" else "🟢"
                            print(f"  {severity_icon} {item.description}")
        
        return 1 if total_issues > 0 else 0
    else:
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Status", "Environment status: OK", "success")
        else:
            print("Environment Status: OK")
        return 0

def handle_config_command(args, cli_manager: CLIManager) -> int:
    """Handle config command with enhanced functionality"""
    if not args.config_action:
        logger.error("Config action is required (get, set, validate, edit, list)")
        return 1
    
    if args.config_action == 'get':
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Configuration", f"Getting value for key: {args.key}", "info")
        print(f"Getting configuration for key: {args.key}")
        # TODO: Implement actual config retrieval
        return 0
        
    elif args.config_action == 'set':
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Configuration", f"Setting {args.key} = {args.value}", "info")
        print(f"Setting {args.key} = {args.value}")
        # TODO: Implement actual config setting
        return 0
        
    elif args.config_action == 'validate':
        environment = getattr(args, 'environment', None) or "development"
        if RICH_AVAILABLE and cli_manager.ui.console:
            with cli_manager.ui.create_progress() as progress:
                task = progress.add_task(f"[cyan]Validating {environment} configuration...", total=100)
                # Simulate validation
                time.sleep(1)
                progress.update(task, completed=100)
            cli_manager.ui.show_status_panel(f"Validation: {environment}", "✅ Configuration is valid", "success")
        else:
            print(f"Validating configuration for {environment}")
            print("✅ Configuration is valid")
        return 0
        
    elif args.config_action == 'edit':
        environment = getattr(args, 'environment', None) or "development"
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Configuration Editor", "Feature coming soon...", "info")
        else:
            print(f"Editing configuration for {environment}")
            print("Feature coming soon...")
        return 0
        
    elif args.config_action == 'list':
        environment = getattr(args, 'environment', None) or "development"
        if RICH_AVAILABLE and cli_manager.ui.console:
            # Example configuration keys
            rows = [
                ["mcp.servers", "Object", "MCP server configurations"],
                ["node.version", "String", "Node.js version requirement"],
                ["claude.workspace", "String", "Claude workspace directory"],
                ["sync.interval", "Number", "Sync interval in seconds"]
            ]
            cli_manager.ui.show_table(
                f"Configuration Keys - {environment}",
                ["Key", "Type", "Description"],
                rows
            )
        else:
            print(f"Configuration keys for {environment}:")
            print("  mcp.servers - MCP server configurations")
            print("  node.version - Node.js version requirement")
            print("  claude.workspace - Claude workspace directory")
            print("  sync.interval - Sync interval in seconds")
        return 0
        
    else:
        logger.error(f"Unknown config action: {args.config_action}")
        return 1

def handle_rollback_command(args, cli_manager: CLIManager) -> int:
    """Handle rollback command with enhanced functionality"""
    if args.list_backups:
        # List available backups
        backup_dir = cli_manager.config_manager.backup_dir
        if not backup_dir.exists():
            if RICH_AVAILABLE and cli_manager.ui.console:
                cli_manager.ui.show_status_panel("Backups", "No backups found", "info")
            else:
                print("No backups found")
            return 0
        
        backups = []
        for backup_path in backup_dir.iterdir():
            if backup_path.is_dir():
                metadata_file = backup_path / "metadata.json"
                if metadata_file.exists():
                    try:
                        with open(metadata_file, 'r') as f:
                            metadata = json.load(f)
                        backups.append([
                            backup_path.name,
                            metadata.get('environment', 'unknown'),
                            metadata.get('description', 'no description'),
                            metadata.get('timestamp', 'unknown')
                        ])
                    except:
                        backups.append([backup_path.name, 'unknown', 'corrupted metadata', 'unknown'])
        
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_table(
                "Available Backups",
                ["Backup ID", "Environment", "Description", "Timestamp"],
                backups
            )
        else:
            print("Available Backups:")
            print("Backup ID\t\tEnvironment\tDescription\t\tTimestamp")
            print("-" * 80)
            for backup in backups:
                print("\t".join(backup))
        return 0
    
    # Perform rollback
    target = None
    target_type = None
    
    if args.to_version:
        target = args.to_version
        target_type = "version"
    elif args.to_commit:
        target = args.to_commit
        target_type = "commit"
    elif args.to_backup:
        target = args.to_backup
        target_type = "backup"
    else:
        logger.error("Rollback target is required (--to-version, --to-commit, or --to-backup)")
        return 1
    
    # Confirmation unless forced
    if not args.force:
        if not cli_manager.ui.prompt_confirm(f"Rollback to {target_type}: {target}?", default=False):
            if RICH_AVAILABLE and cli_manager.ui.console:
                cli_manager.ui.show_status_panel("Rollback", "Rollback cancelled", "warning")
            else:
                print("Rollback cancelled")
            return 0
    
    if RICH_AVAILABLE and cli_manager.ui.console:
        with cli_manager.ui.create_progress() as progress:
            task = progress.add_task(f"[cyan]Rolling back to {target_type}: {target}...", total=100)
            # Simulate rollback
            time.sleep(2)
            progress.update(task, completed=100)
        cli_manager.ui.show_status_panel("Rollback Complete", f"Successfully rolled back to {target_type}: {target}", "success")
    else:
        print(f"Rolling back to {target_type}: {target}")
        print("Rollback completed successfully")
    
    return 0

def handle_diff_command(args, cli_manager: CLIManager) -> int:
    """Handle diff command with enhanced output formats"""
    environment = args.environment or "development"
    drift_items = cli_manager.drift_detector.detect_drift(environment)
    
    if not drift_items:
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Diff Results", "✅ No differences detected", "success")
        else:
            print("✅ No differences detected")
        return 0
    
    if args.output == 'json':
        diff_data = {
            'environment': environment,
            'total_differences': len(drift_items),
            'differences': [{
                'category': item.category,
                'severity': item.severity,
                'description': item.description,
                'current_value': item.current_value,
                'expected_value': item.expected_value,
                'remediation': item.remediation
            } for item in drift_items]
        }
        print(json.dumps(diff_data, indent=2))
        
    elif args.output == 'yaml':
        diff_data = {
            'environment': environment,
            'total_differences': len(drift_items),
            'differences': [{
                'category': item.category,
                'severity': item.severity,
                'description': item.description,
                'current_value': item.current_value,
                'expected_value': item.expected_value,
                'remediation': item.remediation
            } for item in drift_items]
        }
        print(yaml.dump(diff_data, default_flow_style=False))
        
    else:  # table format
        if RICH_AVAILABLE and cli_manager.ui.console:
            rows = []
            for item in drift_items:
                severity_icon = "🔴" if item.severity == "high" else "🟡" if item.severity == "medium" else "🟢"
                rows.append([
                    severity_icon,
                    item.category,
                    item.description[:40] + "..." if len(item.description) > 40 else item.description,
                    str(item.current_value)[:30] + "..." if len(str(item.current_value)) > 30 else str(item.current_value),
                    str(item.expected_value)[:30] + "..." if len(str(item.expected_value)) > 30 else str(item.expected_value)
                ])
            
            cli_manager.ui.show_table(
                f"Configuration Differences - {environment}",
                ["Severity", "Category", "Description", "Current", "Expected"],
                rows
            )
        else:
            print(f"Configuration differences for {environment}:")
            for i, item in enumerate(drift_items, 1):
                print(f"\n{i}. {item.category}: {item.description}")
                print(f"   Current:  {item.current_value}")
                print(f"   Expected: {item.expected_value}")
                print(f"   Fix:      {item.remediation}")
    
    return 0

def handle_backup_command(args, cli_manager: CLIManager) -> int:
    """Handle backup command"""
    if args.backup_action == 'create':
        description = args.description or "manual"
        backup_path = cli_manager.config_manager.backup_config(args.environment, description)
        if RICH_AVAILABLE and cli_manager.ui.console:
            cli_manager.ui.show_status_panel("Backup Created", f"Backup saved to:\n{backup_path}", "success")
        else:
            print(f"Backup created successfully: {backup_path}")
        return 0
        
    elif args.backup_action == 'list':
        # Reuse logic from rollback --list-backups
        return handle_rollback_command(type('args', (), {'list_backups': True})(), cli_manager)
        
    elif args.backup_action == 'restore':
        # Reuse logic from rollback --to-backup
        return handle_rollback_command(type('args', (), {
            'to_backup': args.backup_id, 
            'force': args.force,
            'list_backups': False,
            'to_version': None,
            'to_commit': None
        })(), cli_manager)
        
    else:
        logger.error("Backup action is required (create, list, restore)")
        return 1

def handle_version_command(args) -> int:
    """Handle version command"""
    version_info = {
        'claude-env': '2.0.0',
        'python': sys.version.split()[0],
        'platform': sys.platform,
        'rich_available': RICH_AVAILABLE
    }
    
    if RICH_AVAILABLE:
        console = Console()
        panel = Panel(
            f"[bold blue]Claude Environment Manager[/bold blue]\n"
            f"Version: {version_info['claude-env']}\n"
            f"Python: {version_info['python']}\n"
            f"Platform: {version_info['platform']}\n"
            f"Rich UI: {'✅ Enabled' if version_info['rich_available'] else '❌ Not Available'}",
            title="🚀 Version Information",
            border_style="blue"
        )
        console.print(panel)
    else:
        print("Claude Environment Manager")
        print(f"Version: {version_info['claude-env']}")
        print(f"Python: {version_info['python']}")
        print(f"Platform: {version_info['platform']}")
        print(f"Rich UI: {'Enabled' if version_info['rich_available'] else 'Not Available'}")
    
    return 0

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nGoodbye! 👋")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)